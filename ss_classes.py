"""

Classes for the surround suppression experiment


- Stimulus
- Staircase
- Trial


""" 
import wx
import numpy as np
from psychopy import core, visual, event, gui
from psychopy.sound import SoundPyglet as Sound
from ss_tools import sound_freq_sweep, GetFromGui


class Params(object):
    """
    The Params class stores all of the parameters needed during the execution
    of ss_run.

    Once a parameter is set, it is protected and cannot be changed, unless it
    is explicitely removed from the _dont_touch variable. 

    Some parameters are set upon initialization from the file 'ss_params.py'

    Others are set through a gui which is generated by the method set_by_gui
    
    """
    def __init__(self, p_file='ss_params'):
        """
        Initializer for the params object.

        Parameters
        ----------

        p_file: string, the name of a parameter file, defaults to 'ss_params'

        """
        self._dont_touch = []
        #The following params are read in from a file with dict p.
        im = __import__(p_file)
        for k in im.p.keys():
            self.__setattr__(k,im.p[k])
            self._dont_touch.append(k)

    def __setattr__(self,name,value):
        """
        
        Overloading __setattr__, such that attributes cant be changed once they
        are set, unless they are explicitely removed from the _dont_touch list.

        """

        if name == '_dont_touch':
            super.__setattr__(self,name,value) 
        elif name in self._dont_touch:
            raise ValueError("Parameter %s is protected, please don't touch!"%name)
        else:
            super.__setattr__(self,name,value)
            self._dont_touch.append(name)

    def set_by_gui(self):
        """
        Set additional parameters through a wx GUI object. The wx app needs to
        be started and set in the main loop

        
        """
        
        # Use the GetFromGui class from ss_tools:
        user_choice = GetFromGui(None, -1, 'Session Params',
                                 ['Parallel', 'Orthogonal'])
        # success is achieved if the user presses 'done': 
        if user_choice.success:                
                user_params = {
                    "subject" : user_choice.subject,
                    "surround_ori" : user_choice.surround_ori,
                    "annulus_ori" : user_choice.annulus_ori,
                    "task" : user_choice.TaskType}
        else:
            user_choice.Destroy()
            raise ValueError("Program stopped by user")
        # Stop execution of the window
        user_choice.Destroy()
        
        for k in user_params.keys():
            self.__setattr__(k,user_params[k])

class Event(object):

    """This is the base clase for the events, which sets the template for all
    the events objects """
    def __init__(self,win,**kwargs):
        """
        This always initializes with the window object and with a params
        object
        
        
        """
        #The event has to be attached to some psychopy window object:
        self.win = win 

        #The duration attribute is also necessary: 
        if 'duration' in kwargs.keys():
            self.duration = kwargs['duration']
        else:
            self.duration = 0
            
        #Set the rest of the attributes, if they are provided:
        for k in kwargs:
            self.__setattr__(k,kwargs[k])

    def finalize(self,**kwargs):
        """
        This is a function to finalize the event, before making it happen

        """
        #In the simplest case, just set additional attributes according to the
        #input: 
        for k in kwargs:
            self.__setattr__(k,kwargs[k])
        
    def __call__(self,**kwargs):
        """
        Make the event go for the alloted duration

        This method overloads the __call__ method allowing directly calling 
        the object with the inputs for the event occurence

        """
        
        #Allow to set the duration at this point as well (which would
        #over-ride any previous setting):
        if 'duration' in kwargs.keys():
            self.duration = kwargs['duration']
        

        #In the simplest case, just clear the screen completely at each refresh:
        clock = core.Clock()
        t=0
        while t<self.duration: #Keep going for the duration
            t=clock.getTime()
            #For each of the object attributes, go and check whether it has a
            #'draw' method. If it does, call that method before flipping the
            #window, so that if stimuli objects from psychopy were provided,
            #those will be shown for the duration: 
            for k in self.__dict__:
                try:
                    self.__dict__[k].draw()
                except: #Do nothing in case of an exception:
                    pass
            self.win.flip()

        #Return the entire object at the end, so that we can inspect it:
        return self
    
class Staircase(object):
    """
    This is an object for holding, updating and potentially analyzing
    A psychophysical staircase

    """ 
    def __init__(self,start,step,n_up=3,n_down=1,harder=-1,ub=1,lb=0):
        """
        Initialization function for the staircase class

        Parameters
        ----------
        start: The starting value of the staircase
        step: The size of the step used when updating the staircase
        n_up,n_down: The kind of staircase to be used, defaults to a 3-up,
                     1-down staircase 

        harder: {-1,1} The direction which would make the task harder. Defaults
        to -1, which is true for the contrast decrement detection task.

        """
        self.value = start
        self.n_up = n_up
        self.step = step
        self.n = 0 #This is what will be compared to n_up for udpating.
        self.harder = np.sign(harder) #Make sure that this is only -1 or 1.
        self.record = [start]
        
    def update(self,correct):
        """

        This function updates the staircase value, according to the state of
        the staircase, the n/n_up values and whether or not the subject got it
        right. This staircase is then propagated on to the next trial.

        Parameters
        ----------
        correct: {True|False} 

        """

        if correct:
            if self.n>=self.n_up-1:
                self.value += self.harder * self.step #'harder' sets the sign
                                                      #of the change to make it
                                                      #harder
                self.n = 0
            else:
                self.n +=1
                
        else:
            self.n = 0
            self.value -= self.harder * self.step #Change in the
                                        #opposite direction than above to make
                                        #it easier!

        #Add to the records the updated value: 
        self.record.append(self.value)
    
      
class Stimulus(Event):

    """The surround suppression stimulus, including everything """

    def __init__(self,win,params,surround_contrast=None,surround_ori=None,
                 annulus_contrast=None, annulus_ori=None, fixation_ori=None,
                 fixation_color=None,fixation_shape=None,
                 tex_res = 256):
        """

        Initialize the object, by setting all the various subobjects

        Parameters
        ----------

        win: a psychopy window object

        params: an object with parameters for setting the size and . Note that
        the units of size here need to be the units that were used to
        initialize the window object (should be degrees).

        surround_contrast, surround_ori, annulus_contrast, annulus_ori: These
        variables can be used in order to over-ride the values of these
        variables in the params object. They cannot be set online, after the
        object has been initialized, except by calling the setters of the
        psychopy objects.

        fixation_ori: sometimes we might want to rotate the fixation square to
        some other orientation. This allows this. Defaults to None => upright
        square. 

        fixation_color: If we want to change the color of the fixation from
        white (the default) to some other color (rgb argument). 

        fixation_shape: The shape of the mask applied to the fixation
        {None(default) => square | 'circle'}
        
        tex_res: the resolution (in pixels) at which the OpenGL texture is
        rendered (?).
        """

        #Carry the window object around with you:
        self.win = win
        #The resolution for the textures:
        self.tex_res = tex_res
        #The temporal frequency of the flicker:
        self.temporal_freq = params.temporal_freq

        #Set the params for the different components of the stimulus. The
        #default is to follow what is given by the params:
        if surround_contrast is None:
            surround_contrast = params.surround_contrast
        if surround_ori is None:
            surround_ori = params.surround_ori
        if annulus_contrast is None:
            annulus_contrast = params.annulus_contrast
        if annulus_ori is None:
            annulus_ori = params.annulus_ori
        
        #Set both parts of the surround
        self.outer_surround = visual.PatchStim(self.win,tex="sin",mask="circle",
                                           texRes=tex_res,
                                           color=surround_contrast,
                                           size=(params.surround_outer-
                                                 params.ring_width/2,
                                                 params.surround_outer-
                                                 params.ring_width/2),
                                           sf=params.spatial_freq,
                                           ori = surround_ori)

        self.inner_surround = visual.PatchStim(self.win,tex="sin",mask="circle",
                                               texRes=tex_res,
                                               color=surround_contrast,
                                               size=(params.annulus_inner-
                                                     params.ring_width/2,
                                                     params.annulus_inner-
                                                     params.ring_width/2),
                                               sf=params.spatial_freq,
                                               ori = surround_ori)

        #Set the annulus:
        self.annulus = visual.PatchStim(self.win,tex="sin",mask="circle",
                                        texRes=tex_res,
                                        color=annulus_contrast,
                                        size=(params.annulus_outer-
                                              params.ring_width/2,
                                              params.annulus_outer-
                                              params.ring_width/2),
                                        sf=params.spatial_freq,
                                        ori = annulus_ori)

        #Set the rings abutting the annulus on both sides:
        ring_width = params.ring_width
        spoke_width = params.spoke_width
        #This is the bit between the annulus and the outer surround: 
        self.ring1 = visual.PatchStim(self.win, tex=None, mask='circle',
                                      color=-1, #Always black
                                      size=[params.annulus_outer+ring_width/2,
                                            params.annulus_outer+ring_width/2],
                                      interpolate=True)

        #This is the bit between the annulus and the inner surround: 
        self.ring2 = visual.PatchStim(self.win, tex=None, mask='circle',
                                      color=-1, #Always black
                                      size=[params.annulus_inner+ring_width/2,
                                            params.annulus_inner+ring_width/2],
                                      interpolate=True)

        #This is the central area, between the inner surround and the fixation: 
        self.center_area = visual.PatchStim(self.win, tex=None, mask='circle',
                                            color=0, #Always gray
                                            size=params.surround_inner,
                                            interpolate=True)

        self.spokes = []
        num_spokes = 8 #This is hard-coded for now
        for i in np.arange(num_spokes/2):
            self.spokes.append(visual.ShapeStim(self.win,
                                fillColor = -1,
                                lineColor = -1,
                                vertices = ((-params.spoke_width/2,
                                              params.annulus_outer/2),
                                            (params.spoke_width/2,
                                             -params.annulus_outer/2),
                                            (-params.spoke_width/2,
                                             -params.annulus_outer/2),
                                            (params.spoke_width/2,
                                             params.annulus_outer/2)),
                                ori=i*45))

        # Fixation (made out of two concentric squares):
        # Set the fixation parameters from the input or the defaults:
        if fixation_color is None:
            fixation_color = 1
        if fixation_ori is None:
            fixation_ori = 0

        self.fixation = visual.PatchStim(self.win, tex=None,
                                         color=fixation_color,
                                         size=params.fixation_size,
                                         interpolate=True,
                                         ori=fixation_ori)

        self.fixation_center = visual.PatchStim(self.win, tex=None,
                                                color=0,
                                                size=params.fixation_size/2,
                                                interpolate=True,
                                                ori=fixation_ori)

        def finalize(self,params,target_co=None,target_loc=None,
                     target_ori=None,fix_target_co=None,fix_target_loc=None):

            """

            Finalize the stimulus, by setting the target

            Parameters
            ----------

            params: a parameter object with all the pre-defined params

            target_co: the contrast of the target in this trial (set by the
            staircase). Set to None if no target is to be set in this stimulus
            object 

            target_loc: the location of the target (integer between 0 and 7) in
            this trial. defaults to None => random location

            target_ori: The orientation of the target (typically set to the
            same orientation as the annulus). Defaults to None => the
            orientation given in the params object

            fix_target_co: This allows setting of the fixation contrast (the
            difference between white and black), so that it can serve as a
            target.

            fix_target_loc: the location of the fixation target (right{1} or
            left{otherwise})

            """
            if target_co is None: 
                #Set the target to None per default:
                self.target = None
            #If a target is to be shown, proceed on to set it:
            else: 
                #Throw errors if the contrast values don't make sense:
                if target_co > params.pedestal_contrast:
                    raise ValueError ("Target contrast cannot be larger than the pedestal contrast: %s" %params.pedestal_contrast)

                if target_co < params.min_contrast:
                    raise ValueError("Target contrast cannot be smaller than the minimal contrast: %s"%params.min_contrast) 

                if target_loc is None:
                    #Choose a random one between 0 and 7 (with equal
                    #probabilities):
                    target_loc = int(np.random.rand(1) * 8)
                if target_ori is None:
                    #Get it from the params:
                    target_ori = params.target_ori
                    
                #In order to apply a different contrast to the target wedge,
                #generate a mask, which will cover everything except for the
                #target wedge:
                grid_array = np.linspace(-1*self.annulus.size[0],
                                         self.annulus.size[0],
                                         self.annulus.texRes)

                x,y=np.meshgrid(grid_array,grid_array)
                r = np.sqrt(x**2 + y**2)
                theta = np.arctan2(x,y) + np.pi
                target_mask = np.ones((self.annulus.texRes,self.annulus.texRes))

                target_mask[np.where(r>params.annulus_outer-
                                     params.ring_width/2)] = -1

                target_mask[np.where(r<params.annulus_inner-
                                     params.ring_width/2)] = -1

                #Since the whole PatchStim is rotated according to annulus_ori,
                #we need to adjust for that, so that the target locations
                #remain invariant across different orientations (hence
                #subtraction of annulus_ori):
                target_mask[np.where(theta<target_loc*np.deg2rad(45)-
                                     np.deg2rad(annulus_ori))] = -1
                target_mask[np.where(theta>(target_loc+1)*np.deg2rad(45)-
                                     np.deg2rad(target_ori))] = -1

                #Now show the target contrast in the wedge, using that mask:
                self.target = visual.PatchStim(self.win,tex="sin",
                                               mask=target_mask,
                                               texRes=self.tex_res,
                                               color=target_co, 
                                               size=(params.annulus_outer-
                                                     params.ring_width/2,
                                                     params.annulus_outer-
                                                     params.ring_width/2),
                                               sf=params.spatial_freq,
                                               ori=target_ori)

                #If you want to set the fixation target with a contrast value:
                if fix_target_co is not None:
                    if fix_target_loc == 1:
                        pos = [0,self.fixation_size/2]
                    else:
                        pos = [0,-self.fixation_size/2]
                        
                    self.fixation_target = visual.PatchStim(self.win,
                                            tex=None,
                                            pos = pos,
                                            opacity=1-fix_target_co)
                    
        def __call__(self,params,duration=0):
            #Choose a random phase (btwn -pi and pi) to start the presentation
            #with:
            ph_rand = (np.random.rand(1) * 2*np.pi) - np.pi
            #Start a clock 
            clock = core.Clock()
            while t<duration: #Keep going for the duration
                t=clock.getTime()

                self.annulus.setContrast(np.sin(ph_rand +
                                                t*self.temporal_freq*np.pi*2))
                self.inner_surround.setContrast(np.sin(ph_rand +
                                                t*self.temporal_freq*np.pi*2))
                self.outer_surround.setContrast(np.sin(ph_rand +
                                                t*self.temporal_freq*np.pi*2))
                
                if self.target is not None: 
                    self.target.setContrast(np.sin(ph_rand +
                                            t*self.temporal_freq*np.pi*2))

                #Draw them (order matters!)
                if self.outer_surround is not None:
                    self.outer_surround.draw()
                self.ring1.draw()
                self.annulus.draw()
                if self.target is not None:
                    self.target_wedge.draw()
                for spoke in self.spokes:
                    spoke.draw()
                self.ring2.draw()
                self.inner_surround.draw()
                self.center_area.draw()
                self.fixation.draw()
                self.fixation_center.draw()
                
                win.flip() #update the screen
                
            #Return the object, so that we can inspect it:
            return self

    
class Text(Event):

    """
    A class for showing text on the screen until a key is pressed 
    """

    def __init__ (self,win,text='Press a key to continue',
                  keys=['1','2'],**kwargs):
        """
        
        Will do the default thing(show 'text' in white on gray background),
        unless you pass in kwargs, which will just go through to
        visual.TextStim (see docstring of that class for more details)

        keys: list. The keys to which you listen for input
        """

        self.win = win
        
        self.text = visual.TextStim(win,text=text,**kwargs)
        self.keys=keys
        
    #No need for a 'finalize' method in this case.
    
    def __call__(self,duration=np.inf):
        """
        Text is shown to the screen, until a key is pressed or until duration
        elapses (default = inf)
        
        """

        clock = core.Clock()
        t=0
        while t<duration: #Keep going for the duration
            t=clock.getTime()

            self.text.draw()
            self.win.flip()

            for key in event.getKeys():
                if key in self.keys:
                    return
                



## class Response(Event):

##     """
##     Getting responses from subjects and
    
##     """

    
class Feedback(Event):

    def __init__(self,params):
        """This provides auditory (and visual?) feedback about performance """ 

        self.incorrect_sound = Sound(sound_freq_sweep(8000, 200, .1))
        self.correct_sound = Sound(sound_freq_sweep(1000,1000,.1))
        self.no_respones_sound = Sound(sound_freq_sweep(200, 300, .1))   
        #This will be how long to wait when issued:
        self.duration = params.feedback_duration
        #set the default state to be None
        self.feedback = None
        
    def finalize(self,correct=None):
        """

        What feedback to give depends on whether subjects got it right or
        not

        Parameters
        ----------

        correct: {1|0} for correct incorrect. Default: None => no-response
        """
        if correct is None:
            self.feedback = self.no_respones_sound
        elif correct==1:
            self.feedback = self.correct_sound
        elif correct==0:
            self.feedback = self.incorrect_sound
                   
    def __call__(self):
        """
        Play the feedback
        """
        #Start a clock:
        clock = core.Clock()
        t=0
        
        #If the object wasn't properly finalized for some reason:
        if self.feedback is None:
            self.feedback = self.no_respones_sound
        
        self.feedback.play()
        self.feedback.play() #For some reason need to call play twice 
        
        while t<self.duration: #Keep going for the duration
            t=clock.getTime()
        

        
